# -*- coding: utf-8 -*-
"""PRAC_PROB_Tree&Recursion.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PKzgtveHgkUTJuoZUUH52YKB9ODQsl7n

***TREE***
"""

class BTNode:
  def __init__(self, elem):
    self.elem = elem
    self.right = None
    self.left = None

def inorder(root):
  if root == None:
    return

  inorder(root.left)
  print(root.elem, end = ' ')
  inorder(root.right)

def preorder(root):
    if root==None:
        return
    print(root.elem,end=" ")
    preorder(root.left)
    preorder(root.right)

def postorder(root):
    if root==None:
        return
    postorder(root.left)
    postorder(root.right)
    print(root.elem,end=" ")

def tree_construction(arr, i = 1):
  if i>=len(arr) or arr[i] == None:
    return None
  p = BTNode(arr[i])
  p.left = tree_construction(arr, 2*i)
  p.right = tree_construction(arr, 2*i+1)
  return p

root2 = tree_construction([None, 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', None, None, None, 'I', 'J', None, 'K'])
inorder(root2)
print()
preorder(root2)
print()
postorder(root2)

#Find out the sibling node of a given node
def sibling(root,n,flag=False):
    if root==None:
        return flag
    if root==n:
        return True


    ans1=sibling(root.left,n,flag)
    if ans1!=True:
        ans2=sibling(root.right,n,flag)
        if ans2==True:
            if root.right==n:
                return root.left.elem
            else:
                return root.right.elem


    else:
        return root.right

    if ans1==False and ans2==False:
        return 'None'
    else:
        return ans1 or ans2



root = BTNode(1)
n1 = BTNode(10)
n2 = BTNode(5)
n3 = BTNode(4)
n4 = BTNode(8)
n5 = BTNode(9)
root.left=n1
root.right=n5
n1.left=n2
n1.right=n3
n3.left=n4
print('Given Tree Inorder Traversal: ', end = ' ')
inorder(root) #Given Tree Inorder Traversal:  40 20 60 10 30
print()
print(sibling(root,n4))

#1: Given two binary trees, find if both of them are identical or not.
def identical(root1,root2,i=0,flag=True):
    if root1==None and root2==None:
        return flag

    if root1.elem!=root2.elem and i!=0:
        return False

    ans=identical(root1.left,root2.left,i+1)
    ans=identical(root1.right,root2.right,i+1)

    return ans


root1 = BTNode(1)
n1 = BTNode(2)
n2 = BTNode(3)
root2 = BTNode(1)
n3 = BTNode(2)
n4 = BTNode(3)
root1.left=n1
root1.right=n2
root2.left=n3
root2.right=n4
print(identical(root1,root2))

#2: Given a binary tree, convert it into its mirror.
def convert_mirror(root):
    if root==None:
        return

    convert_mirror(root.left)
    r=root.right
    l=root.left
    root.right=l
    root.left=r
    return root


#DRIVER CODE
root = BTNode(10)
n1 = BTNode(20)
n2 = BTNode(30)
n3 = BTNode(40)
n4 = BTNode(60)

root.left = n1
root.right = n2

n1.left = n3
n1.right = n4

print('Given Tree Inorder Traversal: ', end = ' ')
inorder(root) #Given Tree Inorder Traversal:  40 20 60 10 30
print()

root2 = convert_mirror(root)
print('Mirrored Tree Inorder Traversal: ', end = ' ')
inorder(root2) #Mirrored Tree Inorder Traversal:  30 10 60 20 40

#3: Given a binary tree, find if it is height balanced or not. A tree is height
#balanced if the difference between heights of left and right subtrees is not more
#than one for all nodes of the tree.
def height(root,i=0):
    if root==None:
        return 0
    if root.left==None and root.right==None:
        return 1

    left=height(root.left,i+1)
    right=height(root.right,i+1)
    maximum=max(left,right)
    if i!=0:
        return maximum+1
    else:
        if left>right:
            if left-right>1:
                return 'Unbalanced'
            else:
                return "Balanced"
        else:
            if right-left>1:
                return "Unbalanced"
            else:
                return "Balanced"
#DRIVER CODE
root = BTNode(10)
n1 = BTNode(20)
n2 = BTNode(30)
n3 = BTNode(40)
n4 = BTNode(60)
n5= BTNode(70)

root.left = n1
root.right = n2

n1.left = n3
n1.right = n4
n3.left=n5
ans=height(root)
print(ans)

# 4 Given a binary tree, check whether all of its nodes have the value equal to the
# sum of their child nodes.
def check(root,sum=0,i=0):
    if root==None:
        return 0
    if root.left==None and root.right==None:
        return root.elem
    sum+=check(root.left,sum,i+1)
    sum+=check(root.right,sum,i+1)

    if sum==root.elem and i!=0:
        return sum
    elif sum==root.elem and i==0:
        return True
    else:
        return False
#DRIVER CODE
root = BTNode(11)
n2 = BTNode(8)
n3 = BTNode(3)
n4 = BTNode(5)
n5 = BTNode(2)
root.left=n2
root.right=n3
n2.left=n4
n2.right= n5
print(check(root))

#5 Given a binary tree, find the largest value in each level.
def check(root,d={},i=0):
    if root==None:
        return i-1
    if root.left==None and root.right==None:
        if root.elem not in d:
            if i not in d:
                d[i]=root.elem
            else:
                if d[i]<root.elem:
                    d[i]=root.elem

    if i not in d:
        d[i]=root.elem
    else:
        if d[i]<root.elem:
            d[i]=root.elem
    check(root.left,d,i+1)
    check(root.right,d,i+1)
    return d


#DRIVER CODE
root = tree_construction([None, 4,9,2,3,-5,None,7])
print('Given Tree Inorder Traversal: ', end = ' ')
inorder(root) #Given Tree Inorder Traversal:  3 9 5 4 2 7
print()
print('Level Largest Value: ', end = ' ')
print(check(root))

#6: Given a binary tree, check if it has duplicate values.
def check(root,l=[],c=0,i=0):
    if i==0:
        l.append(root.elem)
    if root==None:
        return
    if root.left==None and root.right==None:
        if root.elem in l:
            c+=1
        l.append(root.elem)
        return c

    ans=check(root.left,l,c,i+1)
    ans=check(root.right,l,c,i+1)

    if i!=0:
        l.append(root.elem)

    if ans>0:
        return 1
    else:
        return 0

root = BTNode(1)
n2 = BTNode(2)
n3 = BTNode(3)
n4 = BTNode(20)
root.left=n2
root.right=n3
n3.right=n4
ans=check(root)
if ans>0:
    print('Yes')
else:
    print('No')

#7: Given a root of a binary tree, and an integer k, print all the nodes which are at
#  k distance from root. Distance is the number of edges in the path from the source
#  node (Root node in our case) to the destination node.
def dist(root,k,i=0):
    if root==None:
        return
    if i==k:
        print(root.elem,end=" ")

    dist(root.left,k,i+1)
    dist(root.right,k,i+1)

#Driver code
root = BTNode(1)
n1 = BTNode(2)
n2 = BTNode(3)
n3 = BTNode(4)
n4 = BTNode(5)
n5= BTNode(8)
n6= BTNode(9)

root.left = n1
root.right = n2

n1.left = n3
n1.right = n4
n2.left=n5
n3.right=n6

dist(root,2)

#8: Given a binary tree and a key, write a function that prints all the ancestors of
#the node with the key in the given binary tree.
def dist(root,x,i=0):
    if root==None:
        return False
    if root.elem==x:
        return True

    flag1=dist(root.left,x,i+1)
    flag2=dist(root.right,x,i+1)
    if flag1==True or flag2==True:
        if i!=0:
            print(root.elem,end=" ")
            return True
        else:
            print(root.elem)


#Driver code
root = BTNode(1)
n1 = BTNode(2)
n2 = BTNode(3)
n3 = BTNode(4)
n4 = BTNode(5)
n5= BTNode(7)

root.left = n1
root.right = n2

n1.left = n3
n1.right = n4
n3.left=n5


dist(root,n5.elem)

#9 Given a binary tree, print all the nodes having exactly one child. Print “-1” if no such
# node exists.
def myfun(root,flag=False,i=0):
    if root==None:
        return flag
    if root.left==None and root.right==None:
        return False
    if (root.left==None and root.right!=None) or (root.left!=None and root.right==None):
        print(root.elem)
        return True

    flag1=myfun(root.left,flag,i+1)
    flag2=myfun(root.right,flag1,i+1)

    if flag1==True or flag2==True:
        return True
    if i==0:
        if flag1==False and flag2==False:
            print('-1')
    else:
        return flag1 or flag2

#Driver code
root = BTNode(2)
n1 = BTNode(3)
n2 = BTNode(5)
n3 = BTNode(7)
n4 = BTNode(8)
n5= BTNode(6)
n6=BTNode(9)

root.left = n1
root.right = n2
n1.left=n3
n1.right=n6
n2.left=n4
n2.right=n5

print(myfun(root))

#10: Given a binary tree, check whether it is a skewed binary tree or not. A skewed
# tree is a tree where each node has only one child node or none.
def check(root):
    if root==None:
        return
    if root.left!=None and root.right!=None:
        return "No"

    ans1=check(root.left)
    ans2=check(root.right)

    if ans1=="No" or ans2=="No":
        return 'No'
    else:
        return 'Yes'

root = BTNode(5)
n1 = BTNode(4)
n2 = BTNode(3)
n3 = BTNode(2)
n4 = BTNode(8)

root.left=n1
n1.right=n2
n2.left=n3
n2.right=n4

print(check(root))

#11: Given a binary tree, find its minimum depth. The minimum depth is the number of
# nodes along the shortest path from the root node down to the nearest leaf node.
def dep(root,i=0):
    if root==None:
        return 0
    if root.left==None and root.right==None:
        return i

    ans1=dep(root.left,i+1)
    ans2=dep(root.right,i+1)

    if i!=0:
        if ans1>=ans2 and ans2!=0:
            return ans2
        else:
            return ans1
    else:
        if ans1>ans2 and ans2!=0:
            return ans2+1
        else:
            return ans1+1



#Driver code
root = BTNode(1)
n1 = BTNode(2)
n2 = BTNode(3)
n3 = BTNode(4)
n4 = BTNode(5)
n5= BTNode(7)
n6= BTNode(9)
n7=BTNode(5)

root.left = n1
root.right= n2

n1.left = n3
# n1.right = n4
n3.left=n5

n2.right=n7
# n2.left=n6
n7.right=n6

print(dep(root))

#12: Given a binary tree, print all nodes that are full nodes. Full nodes are nodes
# which have both left and right children as non-empty.
def myfun(root):
    if root==None:
        return
    if root.left!=None and root.right!=None:
        print(root.elem,end=" ")

    myfun(root.left)
    myfun(root.right)

#DRIVER CODE
root = BTNode(10)
n1 = BTNode(8)
n2 = BTNode(2)
n3 = BTNode(3)
n4 = BTNode(5)
n5= BTNode(7)

root.left = n1
root.right = n2

n1.left = n3
n1.right = n4
n2.left=n5
myfun(root)

#Write a recursive function subtract_summation() that takes the root of a binary tree as a
# parameter. The function will subtract the summation of the right subtree of the given
# root from the summation of the left subtree of the given root. Consider, the Node class
# for Binary Tree already defined with elem, left and right variables. You can use helper
# functions
def sub(root,suml=0,sumr=0,i=0,checker=True):
    if root==None:
        return 0
    if root.left==None and root.right==None:
        return root.elem

    if i==0:
        suml+=sub(root.left,0,0,i+1,True)
        sumr+=sub(root.right,0,0,i+1,False)
    else:
        if checker==True:
            suml+=sub(root.left,0,0,i+1,True)
            suml+=sub(root.right,0,0,i+1,True)
        else:
            sumr+=sub(root.left,0,0,i+1,False)
            sumr+=sub(root.right,0,0,i+1,False)

    if i!=0:
        if checker==True:
            suml+=root.elem
        else:
            sumr+=root.elem

    if i==0:
        return suml-sumr
    else:
        return suml or sumr

#DRIVER CODE
root = BTNode(71)
n1 = BTNode(27)
n2 = BTNode(62)
n3 = BTNode(80)
n4 = BTNode(75)
n5 = BTNode(87)
n6 = BTNode(56)
n7= BTNode(41)
n8= BTNode(3)
n9= BTNode(19)
n10= BTNode(89)

root.left=n1
root.right=n2
n1.left=n3
n1.right=n4
n3.left=n5
n3.right=n6
n2.left=n7
n2.right=n8
n8.left=n9
n8.right=n10

print(sub(root))

#MTT_6: Write a Python function isSymmetric(root) that takes the root of a binary tree,
#check whether it is a mirror of itself (i.e., symmetric around its center).
def sym(root,left="",right="",i=0,checker=True):
    if root==None:
        return str(0)
    if root.left==None and root.right==None:
        return str(root.elem)

    if i==0:
        left+=sym(root.left,"","",i+1,True)
        right+=sym(root.right,"","",i+1,False)
    else:
        if checker==True:
            left+=sym(root.left,"","",i+1,True)
            left+=sym(root.right,"","",i+1,True)
        else:
            right+=sym(root.right,"","",i+1,False)
            right+=sym(root.left,"","",i+1,False)

    if i!=0:
        left+=str(root.elem)
        right+=str(root.elem)
        if len(left)>len(right):
            return left
        else:
            return right
    else:
        if left==right:
            return "Symmetric"
        else:
            return "Non Symmetric"



root = BTNode(1)
n1 = BTNode(2)
n2 = BTNode(2)
n3 = BTNode(3)
n4 = BTNode(4)
n5 = BTNode(4)
n6 = BTNode(3)

root.left=n1
root.right=n2
n1.left=n3
n1.right=n4
n2.left= n5
n2.right=n6
print(sym(root))

#MTT_7:Write a method hasPathSum which takes a root of a binary tree and a targetSum as input
#parameters, return True if the tree has a root-to-leaf path such that adding up all the
# values along the path equals targetSum, False otherwise.
def hasPathSum(root,n,sum=0,flag=False):
    if root==None:
        if sum==n:
            return True
        else:
            return False

    sum+=root.elem
    flag=hasPathSum(root.left,n,sum,flag)
    if flag==False:
        flag=hasPathSum(root.right,n,sum,flag)

    return flag

root = BTNode(5)
n1 = BTNode(4)
n2 = BTNode(8)
n3 = BTNode(11)
n4 = BTNode(13)
n5 = BTNode(17)
n6 = BTNode(7)
n7= BTNode(2)
n8= BTNode(1)
root.left=n1
root.right=n2
n1.left=n3
n3.left=n6
n3.right=n7
n2.left=n4
n2.right=n5
n4.right=n8
print(hasPathSum(root,27))

"""***BST***"""

# 1. Given the root of a binary tree, check whether it is a BST or not.
def search(root,i=0,flag=1):
    if root==None:
        return flag
    if root.left==None and root.right==None:
        return flag

    # elif root.left==None:
    #     if root.elem>root.right.elem:
    #         return 0
    # elif root.right==None:
    #     if root.elem>root.right.elem:
    #         return 0

    ans1=search(root.left,flag)
    if root.left!=None and root.right!=None:
        if root.left.elem<root.elem or root.right.elem>root.elem:
            return
    flag=search(root.right,flag)

    return flag


#DRIVER CODE
root= tree_construction([None,10,7,12,6,11,13,26])
# root = BTNode(2)
# n1 = BTNode(1)
# n2 = BTNode(3)
# # root.left=n1
# root.right=n2
# n2.right=n1
print(search(root))

#2. Given a sorted array. Write a function that creates a Balanced Binary Search Tree using
def create(arr):
    if len(arr)==0:
        return None
    mid=len(arr)//2
    root=BTNode(arr[mid])
    root.left=create(arr[:mid])
    root.right=create(arr[mid+1:])
    return root

nums=[1,2,3,4,5,6,7]
root=create(nums)
inorder(root)
print()
preorder(root)
print()
postorder(root)

#3. Given a BST, and a reference to a Node x in the BST. Find the Inorder Successor of the
# given node in the BST.
def successor(root,x):
    if root==None:
        return

    if root.left==None and root.right==None:
        return root.elem

    if root.elem==x:
        ans=successor(root.right,x)

    if x<root.elem:
        ans=successor(root.left,x)
    else:
        ans=successor(root.right,x)

    return ans

#DRIVER CODE
root = BTNode(20)
n1 = BTNode(8)
n2 = BTNode(22)
n3 = BTNode(4)
n4 = BTNode(12)
n5 = BTNode(10)
n6 = BTNode(14)
n7= BTNode(21)

root.left = n1
root.right = n2

n1.left = n3
n1.right = n4

n4.left = n5
n4.right = n6
n2.left=n7
print(successor(root,root.elem))

#4. Given a Binary search tree, your task is to complete the function which will return the
# Kth largest element without doing any modification in the Binary Search Tree.
def find(root,k,i=0):
    if root==None:
        return 1
    if root.left==None and root.right==None:
        return 1

    i+=find(root.right,k)
    if i==k:
        return root.elem
    else:
        i+=find(root.left,k)
        if i==k:
            return root.elem

    return root.elem-i


root = BTNode(4)
n1 = BTNode(2)
n2 = BTNode(9)
root.left = n1
root.right = n2
find(root,2)

#MTT_8: Create a function that checks whether a given binary tree is a valid Binary Search Tree (BST).
# A BST is a binary tree where the left subtree of a node contains only nodes with values less
#than the node's value, and the right subtree contains only nodes with values greater than the
#node's value
def check(root,flag=True):
    if root==None:
        return flag
    if root.left!=None and root.right!=None:
        if root.left.elem<root.elem< root.right.elem:
            flag=True
        else:
            flag=False
    else:
        return flag

    flag=check(root.left,flag)
    flag=check(root.right,flag)

    return flag

root = BTNode(10)
n1 = BTNode(7)
n2 = BTNode(12)
n3 = BTNode(9)
n4 = BTNode(8)

root.left=n1
root.right=n2
n1.left=n3
n1.right=n4
check(root)

#MTT_9: Evaluate a given binary expression tree representing algebraic expressions. A binary
# expression tree is a binary tree, where the operators are stored in the tree’s internal nodes,
# and the leaves contain constants. Assume that each node of the binary expression tree has zero
#or two children. The supported operators are +, -, * and /.
def calc(root,i=0):
    # if root==None:
    #     return 0
    if root.left==None and root.right==None:
        return root.elem

    left=calc(root.left,i+1)
    right=calc(root.right,i+1)

    if root.elem=='+':
        return int(left+right)
    elif root.elem=='-':
        return int(left-right)
    elif root.elem=='*':
        return int(left*right)
    elif root.elem=='/':
        return int(left/right)

root = BTNode('+')
n1 = BTNode('/')
n2 = BTNode('*')
n3 = BTNode('*')
n4 = BTNode('-')
n5 = BTNode(2)
n6 = BTNode(3)
n7= BTNode(2)
n8= BTNode(1)
n9= BTNode(5)
n10= BTNode('-')
n11= BTNode(4)
n12= BTNode(1)

root.left=n1
root.right=n2
n1.left=n3
n1.right=n4
n3.left=n5
n3.right=n6
n4.left=n7
n4.right=n8
n2.left=n9
n2.right=n10
n10.left=n11
n10.right=n12

print(calc(root))

#Level and Node coount
def level(root,i=0):
    if root==None:
        return 0
    if root.left==None and root.right==None:
        return 1

    left=level(root.left,i+1)
    right=level(root.right,i+1)
    maximum=max(left,right)
    if i!=0:
        return maximum
    else:
        return maximum+1

def count(root,i=0,c=0):
    if root==None:
        return 0
    if root.left==None and root.right==None:
        return 1

    c+=count(root.left,i+1)
    c+=count(root.right,i+1)

    if i!=0:
        c+=1
        return c
    else:
        return c+1


root = BTNode(1)
n1 = BTNode(10)
n2 = BTNode(5)
n3 = BTNode(4)
n4 = BTNode(8)
n5 = BTNode(9)
root.left=n1
root.right=n5
n1.left=n2
n1.right=n3
n3.left=n4
print(level(root))
print(count(root))

#Complete tree
def complete(root,i=0,flag=False):
    if flag!=False:
        return flag
    if root==None:
        return flag
    if root.left==None and root.right==None:
        return flag
    if root.left!=None and root.right==None:
        return True
    else:
        return False

    flag=complete(root.left,i+1,flag)
    flag=complete(root.right,i+1,flag)

    return flag


root = BTNode(20)
n1 = BTNode(8)
n2 = BTNode(22)
n3 = BTNode(4)
n4 = BTNode(12)
n5 = BTNode(10)
n6 = BTNode(14)
n7= BTNode(21)

root.left=n1
root.right=n2
n1.left=n3
n3.left=n5
# n1.right=n4
# n4.right=n5
n2.left=n6
n2.right=n7
print(complete(root))

#Full tree

"""***RECURSION***"""

# You must run this cell to install dependency
! pip3 install fhm-unittest
! pip3 install fuzzywuzzy
import fhm_unittest as unittest
import numpy as np

#1: Given a non-negative int n, return the sum of its digits recursively (no loops).
# Note that mod (%) by 10 yields the rightmost digit (126 % 10 is 6), while divide (/)
#by 10 removes the rightmost digit (126 / 10 is 12).
def sumDigits(n,sum=0):
    if n==0:
        return 0

    sum=n%10+sumDigits(n//10)
    return sum
n=126
print(sumDigits(n))
n=49
print(sumDigits(n))
n=12
print(sumDigits(n))

#2: We have bunnies standing in a line, numbered 1, 2, ... The odd bunnies (1, 3, ..)
# have the normal 2 ears. The even bunnies (2, 4, ..) we'll say have 3 ears, because
# they each have a raised foot. Recursively return the number of "ears" in the bunny
# line 1, 2, ... n (without loops or multiplication).
def bunnyEars2(n,total=0):
    if n==0:
        return 0

    if n%2==0:
        add= 3
    else:
        add=2

    total=add+bunnyEars2(n-1)
    return total


print(bunnyEars2(0))
print(bunnyEars2(1))
print(bunnyEars2(2))

#3: Given a non-negative int n, return the count of the occurrences of 7 as a digit,
# so for example 717 yields 2. (no loops). Note that mod (%) by 10 yields the
# rightmost digit (126 % 10 is 6), while divide (/) by 10 removes the rightmost digit
# (126 / 10 is 12).
def count7(n,count=0):
    if n==0:
        return 0

    num=n%10
    if num==7:
        x=1
    else:
        x=0

    count=x+count7(n//10)

    return count

print(count7(717))
print(count7(7))
print(count7(123))

#4: Given a string, compute recursively (no loops) the number of lowercase 'x' chars
# in the string.
def countX(s,count=0):
    if s=="":
        return 0

    om=s[-1:]
    if om=='x':
        add=1
    else:
        add=0

    count=add+countX(s[:-1])
    return count

print(countX("xxhixx"))
print(countX("xhixhix"))
print(countX("hi"))

#5: Given a string, compute recursively (no loops) a new string where all appearances
#  of "pi" have been replaced by "3.14".
def changePi(s,new=""):
    if s=="":
        return ""

    n2=s[-2:]
    if n2=="pi":
        new=changePi(s[:-2])+"3.14"
    else:
        new=changePi(s[:-1])+s[-1:]

    return new

print(changePi("xpix"))
print(changePi("pipi"))
print(changePi("pip"))

#6: Given an array of ints, compute recursively the number of times that the value 11
# appears in the array. We'll use the convention of considering only the part of the
# array that begins at the given index. In this way, a recursive call can pass index+1
# to move down the array. The initial call will pass in index as 0.
def array11(arr,i,count=0):
    if i==len(arr):
        return 0

    if arr[i]==11:
        k=1
    else:
        k=0
    count=k+array11(arr,i+1)
    return count

print(array11([1, 2, 11], 0))
print(array11([11, 11], 0))
print(array11([1, 2, 3,4], 0))

#7: Given a string, compute recursively a new string where identical chars that are
# adjacent in the original string are separated from each other by a "*".
def pairStar(s,new=""):
    if s=="":
        return ""

    n1=s[-1:]
    n2=s[-2:-1]
    if n2==n1:
        new=pairStar(s[:-1])+"*"+n1
    else:
        new=pairStar(s[:-1])+s[-1:]

    return new


print(pairStar("hello"))
print(pairStar("xxyy"))
print(pairStar("aaaa"))

#8: Count recursively the total number of "abc" and "aba" substrings that appear
# in the given string.
def countAbc(s,count=0):
    if s=="":
        return 0

    n=s[-3:]
    if n=='abc' or n=='aba':
        count=1+countAbc(s[:-3])
    else:
        count=0+countAbc(s[:-1])

    return count

print(countAbc("abc"))
print(countAbc("abcxxabc"))
print(countAbc("abaxxaba"))

#9: Given a string, compute recursively the number of times lowercase "hi" appears
# in the string, however do not count "hi" that have an 'x' immedately before them.
def countHi2(s,count=0):
    if s=="":
        return 0

    n=s[-2:]
    if n=='hi':
        if s[-3:-2]!='x':
            count=1+countHi2(s[:-2])
        else:
            count=0+countHi2(s[:-2])
    else:
        count=0+countHi2(s[:-1])

    return count


print(countHi2('ahixhi'))
print(countHi2('ahibhi'))
print(countHi2('xhixhi'))

#10: Given a string and a non-empty substring sub, compute recursively the number of
# times that sub appears in the string, without the sub strings overlapping.
def strCount(s,word,count=0):
    if s=="":
        return 0

    n=s[-len(word):]
    if n==word:
        count=1+strCount(s[:-len(word)],word)
    else:
        count=0+strCount(s[:-len(word)],word)

    return count


print(strCount("catcowcat", "cat"))
print(strCount("catcowcat", "cow"))
print(strCount("catcowcat", "dog"))

# #11: We have a number of bunnies and each bunny has two big floppy ears. We want to
# compute the total number of ears across all the bunnies recursively (without loops or
# multiplication).
def bunnyEars(s,sum=0,i=0):
    if i>s:
        return 0

    if i==0:
        sum=0+bunnyEars(s,0,i+1)
    else:
        sum=2+bunnyEars(s,0,i+1)

    return sum

print(bunnyEars(0))
print(bunnyEars(1))
print(bunnyEars(2))

#12: We have triangle made of blocks. The topmost row has 1 block, the next row down has
# 2 blocks, the next row has 3 blocks, and so on. Compute recursively (no loops or
# multiplication) the total number of blocks in such a triangle with the given number
# of rows.
def triangle(n,sum=0,i=1):
    if i>n:
        return 0
    else:
        sum=i+triangle(n,0,i+1)
    return sum

print(triangle(0))
print(triangle(1))
print(triangle(2))

#13: Given a string, compute recursively a new string where all the 'x' chars have
#been removed.
def noX(s,s1=""):
    if s=="":
        return ""

    elem=s[-1:]
    if elem=='x':
        s1=noX(s[:-1])+""
    else:
        s1=noX(s[:-1])+elem

    return s1

print(noX('xaxb'))
print(noX('abc'))
print(noX('xx'))

#14:Given an array of ints, compute recursively if the array contains somewhere a value
#followed in the array by that value times 10. We'll use the convention of considering
#only the part of the array that begins at the given index. In this way, a recursive
#call can pass index+1 to move down the array. The initial call will pass in index as 0.
def array220(arr,i,flag=False):
    if i>=len(arr):
        return flag
    if flag==True:
        return flag

    s=check(arr,arr[i])
    flag=array220(arr,i+1,s)

    return flag


def check(arr,num,idx=0,flag=False):
    if idx>=len(arr):
        return flag
    if arr[idx]/num==10:
        return True
    else:
        flag=check(arr,num,idx+1,flag)
    return flag


print(array220([1,2,20],0))
print(array220([3,30],0))
print(array220([3],0))

#15:Given a string, compute recursively a new string where all the lowercase 'x'
#chars have been moved to the end of the string.
def endX(s,i=0,s1="",s2=""):
    if i==len(s):
        new=s2+s1
        return new

    elem=s[i]
    if elem=='x':
        s1+=elem
    else:
        s2+=elem
    ans=endX(s,i+1,s1,s2)
    return ans

print(endX('xxre'))
print(endX('xxhixx'))
print(endX('xhixhix'))

#16: Given a string, compute recursively (no loops) the number of "11" substrings in the string.
#  The "11" substrings should not overlap.
def count11(s,c=0):
    if s=="":
        return 0
    elem=s[-2:]
    if elem=='11':
        c=1+count11(s[:-2])
    else:
        c=count11(s[:-1])

    return c


print(count11('11abc11'))
print(count11('abc11x11x11'))
print(count11('111'))

#17: Given a string that contains a single pair of parenthesis, compute recursively a new
# string  made of only of the parenthesis and their contents, so "xyz(abc)123" yields "(abc)".
def parentBit(s,i=0,s1="",flag=False):
    if s[i]==')':
        return s1+s[i]

    if s[i]=='(' or flag==True:
        s1+=s[i]
        s=parentBit(s,i+1,s1,True)
    else:
        s=parentBit(s,i+1,s1,False)

    return s

print(parentBit('xyz(abc)123'))
print(parentBit('xyz(hello)'))
print(parentBit('(xy)1'))

#18 Given a string and a non-empty substring sub, compute recursively if at least n copies of sub
# appear in the string somewhere, possibly with overlapping. N will be non-negative.
def strCount(s,word,num,i=0,count=0):
    if s=="":
        return 0

    n=s[-len(word):]
    if n==word:
        count=1+strCount(s[:-len(word)],word,num,i+1)
    else:
        count=strCount(s[:-len(word)],word,num,i+1)

    if i==0:
        if count==num:
            return True
        else:
            return False
    else:
        return count


print(strCount("catcowcat", "cat",2))
print(strCount("catcowcat", "cow",2))
print(strCount("catcowcat", "cow",1))

#Construct a method isPrime(num) which will take a number, num as an input. The method will
# return True if the given number is prime, otherwise will return False.
# You have to recursively check for divisibility of the number with the help of a recursive helper
# function having an extra parameter which will be called inside isPrime(num) method
def isPrime(n,i=1,flag=False):
    if i==n:
        return flag
    elif i!=1 and i!=n:
        if n%i==0:
            return True
    else:
        flag=isPrime(n,i+1,flag)

    return flag


print(isPrime(51))
print(isPrime(17))
print(isPrime(16))

#Write a recursive function, digital_root, that takes a positive integer and returns
# its digital root. The digital root is the recursive sum of all the digits until a
#single-digit number is obtained.
def digital_number(n,ans=0,i=0):
    if n==0:
        return 0
    add=n%10
    ans=add+digital_number(n//10,0,i+1)
    if i==0:
        res=helper(ans)
        return res
    else:
        return ans

def helper(ans,sum=0):
    if ans==0:
        return 0
    add=ans%10
    sum=add+helper(ans//10)
    return sum

print(digital_number(942))
print(digital_number(8765))

# Create a recursive function named generate_parentheses that accepts a positive
# integer n as input and produces a string representing a specific pattern of
# parentheses. The pattern should consist of (n-1) pairs of parentheses, all nested
# within an additional pair.
def paran(n,s="(",i=0):
    if n==0:
        return 0
    if i==n:
        return ")"
    else:
        s+="()"

    s+=paran(n,"",i+1)
    return s

print(paran(3))
print(paran(4))

#Write a recursive function named replace_consonants that takes a string as input and
#replaces all consonants with the letter 'X'. The function should return the modified
#string.
def replace(s,s1="",i=0):
    if i>len(s)-1:
        return ""

    if s[i] in "A E I O U a e i o u , . ! ?":
        s1=s[i]+replace(s,'',i+1)
    else:
        s1='X'+replace(s,'',i+1)

    return s1


print(replace('Hello, World!'))

#Develop a recursive function named alternating_sum that takes a list of integers
#as input and computes the alternating sum by subtracting every other number.
#The function should return the result.
def alt(lst,sum=0,i=0):
    if i>=len(lst):
        return 0
    if lst[i]%2==0:
        add=-lst[i]
    else:
        add=lst[i]
    sum=add+alt(lst,0,i+1)

    return sum

print(alt([1,2,3,4,5]))